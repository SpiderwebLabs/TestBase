import rclpy
import threading
from rclpy.node import Node
from threading import Lock
from rclpy.executors import MultiThreadedExecutor
from mavsdk import System
from mavsdk.mission import (MissionItem, MissionPlan)
from more_interfaces.srv import Comms
from more_interfaces.msg import Trials1
from geopy import distance
from decimal import Decimal
import asyncio


class DroneControllerNode(Node):
    def __init__(self):
        super().__init__('drone_controller')

        # Create a publisher for telemetry data
        self.telemetry_publisher = self.create_publisher(Trials1, 'status_update', 10)

        # Create a service for setting drone actions
        self.set_comm_service = self.create_service(Comms, 'set_comms', self.callback_set_comm)
        self.drone = System()

        # Connect to the drone
        self.connect_to_drone()

        # Initialize drone action and other variables
        self.drone_action = None
        self.flight_longitude = 0.0
        self.flight_latitude = 0.0
        self.flight_altitude = 0.0
        self.desired_yaw = 0.0
        self.start_stop_pollflag = False
        # Start the poll_telemetry coroutine in the background
        asyncio.ensure_future(self.poll_telemetry())

         

    def connect_to_drone(self):
        self.get_logger().info('Waiting for the drone to connect...')

        loop = asyncio.get_event_loop()
        try:
            loop.run_until_complete(self._connect_to_drone())
        except Exception as e:
            self.get_logger().error(f"Drone connection failed: {str(e)}")

        self.get_logger().info('Drone connected')

    async def _connect_to_drone(self):
        await self.drone.connect(system_address="udp://:14540")

    async def callback_set_comm(self, request, response):
        self.get_logger().info("set_drone_action")
        self.drone_action = request.message
        self.flight_longitude = request.pos_longitude
        self.flight_latitude = request.pos_latitude
        self.flight_altitude = request.pos_altitude
        self.desired_yaw = request.turn_yaw
        self.start_stop_pollflag = True
        await self.drone_mission()
        response.connect_success = True
        return response

    async def drone_mission(self):
        if self.drone_action == "Clearmission":
            await self.drone.action.hold()
        elif self.drone_action == "Takeoff":
            await self.drone.action.arm()
            await self.drone.action.takeoff()
            self.start_stop_pollflag = False
        elif self.drone_action == "Land":
            await self.drone.action.land()
        elif self.drone_action == "Goto":
            lon = Decimal(self.flight_longitude)
            lat = Decimal(self.flight_latitude)
            alt = Decimal(self.flight_altitude)
            await self.drone.action.arm()
            await self.upload_and_start_new_mission(lat, lon)
        elif self.drone_action == "Turn":
            lon = Decimal(self.flight_longitude)
            lat = Decimal(self.flight_latitude)
            alt = Decimal(self.flight_altitude)
            await self.drone.action.goto_location(lat, lon, alt, self.desired_yaw)
        elif self.drone_action == "Goback":
            await self.drone.action.return_to_launch()

        # Continue polling telemetry after executing the action
        await self.poll_telemetry()

    async def upload_and_start_new_mission(self, lat, lon):
        mission_items = []
        mission_items.append(MissionItem(
            lat,
            lon,
            5.0,
            3.0,
            True,
            float('nan'),
            float('nan'),
            MissionItem.CameraAction.NONE,
            5.0,
            float('nan'),
            3.0,
            float('nan'),
            float('nan')))
        mission_plan = MissionPlan(mission_items)
        await self.drone.mission.upload_mission(mission_plan)
        await self.drone.mission.start_mission()

    async def poll_telemetry(self):
        if self.start_stop_pollflag == False:
            print('here')
            # Poll telemetry data
            while rclpy.ok():
                # Get the telemetry data concurrently
                position_task = self.get_first_value(self.drone.telemetry.position())
                armed_task = self.get_first_value(self.drone.telemetry.armed())
                in_air_task = self.get_first_value(self.drone.telemetry.in_air())
                battery_task = self.get_first_value(self.drone.telemetry.battery())
                gps_satellites_task = self.get_first_value(self.drone.telemetry.gps_info())
                velocity_task = self.get_first_value(self.drone.telemetry.velocity_ned())
                current_yaw_task = self.get_first_value(self.drone.telemetry.attitude_euler())

                # Wait for all telemetry tasks to complete
                position = await position_task
                armed = await armed_task
                in_air = await in_air_task
                battery = await battery_task
                velocity = await velocity_task
                gps_satellites = await gps_satellites_task
                current_yaw = await current_yaw_task

                # Publish the telemetry status
                msg = Trials1()
                msg.armed = armed
                msg.is_in_air = in_air
                msg.battery_percentage = battery.remaining_percent
                msg.pos_latitude = position.latitude_deg
                msg.pos_longitude = position.longitude_deg
                msg.pos_altitude = position.relative_altitude_m
                msg.gps_satellites = gps_satellites.num_satellites
                msg.velocity_x = velocity.north_m_s
                msg.velocity_y = velocity.east_m_s
                msg.velocity_z = velocity.down_m_s
                msg.mission_done = False
                msg.current_yaw = current_yaw.yaw_deg

                self.telemetry_publisher.publish(msg)

                # Sleep for 0.1 seconds (10Hz)
                await asyncio.sleep(0.1)

    async def get_first_value(self, aiter):
        async for value in aiter:
            return value
        return None
    
def main(args=None):
    rclpy.init(args=args)
    drone_controller_node = DroneControllerNode()
    try:
        executor = MultiThreadedExecutor()
        executor.add_node(drone_controller_node)
        executor.spin()
    except KeyboardInterrupt:
        pass
    finally:
        executor.shutdown()
        drone_controller_node.destroy_node()
        rclpy.shutdown()



if __name__ == '__main__':
    main()
